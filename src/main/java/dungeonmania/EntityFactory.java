package dungeonmania;

import dungeonmania.CollectibleEntities.*;
import dungeonmania.MovingEntities.*;
import dungeonmania.StaticEntities.*;
import dungeonmania.util.Position;
import dungeonmania.util.UtilityFunctions;

import static dungeonmania.DungeonManiaController.getDmc;



import org.json.JSONObject;


public class EntityFactory {
    private static int currentEntityID = 0;
    public static int getCurrentEntityID() {
        return currentEntityID;
    }
    private static String getNewEntityID() {
        String newID = Integer.toString(currentEntityID);
        currentEntityID += 1;
        return newID;
    }
    public static void setCurrentEntityID(int newCurrentEntityID) {
        currentEntityID = newCurrentEntityID;
    }

    /**
     * creates an entity with a new unique id generated by the factory
     * @param type
     * @param position
     * @param extraInfo
     * @return
     */
    public static Entity createEntity(String type, Position position, JSONObject extraInfo) {
        String id = getNewEntityID();
        return createEntity(id, type, position, extraInfo);
    }

    /**
     * Creates an entity with a unique id and returns it
     * Used for creating a new game, spawning enemies, and loading old games
     * @param id
     * @param type
     * @param position
     * @param extraInfo - used when creating portals, keys and doors, otherwise leave null
     */
    public static Entity createEntity(String id, String type, Position position, JSONObject extraInfo) {
        JSONObject config = getDmc().getConfig();
        if (extraInfo == null) extraInfo = new JSONObject();
        Entity newEntity = null;
        switch (type) {
            case "player":
                // loading old player
                if (extraInfo.has("health") && extraInfo.has("inventory")) {
                    newEntity = new Player(id, position, 
                        new Position(extraInfo.getInt("prevX"), extraInfo.getInt("prevY")), 
                        extraInfo.getJSONArray("inventory"), 
                        config.getInt("player_attack"), extraInfo.getDouble("health"));
                } else {
                    newEntity = new Player(id, position, config.getInt("player_health"), config.getInt("player_attack"));
                }
                break;
            case "wall":
                newEntity = new Wall(id, position);
                break;
            case "exit":
                newEntity = new Exit(id, position);
                if (extraInfo.has("activated")) {
                    ((Switch) newEntity).setActivated(extraInfo.getBoolean("activated"));
                }
                break;
            case "boulder":
                newEntity = new Boulder(id, position);
                break;
            case "switch":
                if (extraInfo.has("logic")) {
                    newEntity = new LogicalSwitch(id, position, extraInfo.getString("logic"));
                }
                else {
                    newEntity = new FloorSwitch(id, position);
                }
                if (extraInfo.has("activated")) {
                        ((Switch) newEntity).setActivated(extraInfo.getBoolean("activated"));
                }
                break;
            case "door":
                newEntity = new Door(id, position, extraInfo.getInt("key"));
                if (extraInfo.has("locked") && !extraInfo.getBoolean("locked")) {
                    ((Door) newEntity).unlock();
                }
                break;
            case "portal":
                newEntity = new Portal(id, position, extraInfo.getString("colour"));
                break;
            case "zombie_toast_spawner":
                newEntity = new ZombieToastSpawner(id, position, config.getInt("zombie_spawn_rate"));
                break;
            case "swamp_tile":
                newEntity = new SwampTile(id, position, extraInfo.getInt("movement_factor"));
                break;
            case "spider":
                newEntity = new Spider(id, position, config.getInt("spider_health"), config.getInt("spider_attack"));
                break;
            case "zombie_toast":
                newEntity = new ZombieToast(id, position, config.getInt("zombie_health"), config.getInt("zombie_attack"));
                getDmc().getPlayer().subscribe((PlayerListener) newEntity);
                break;
            case "mercenary":
                newEntity = new Mercenary(id, position, config.getInt("mercenary_health"), config.getInt("mercenary_attack"));
                if (extraInfo.has("isFriendly")) {
                    ((Mercenary) newEntity).setFriendly(extraInfo.getBoolean("isFriendly"));
                }
                getDmc().getPlayer().subscribe((PlayerListener) newEntity);
                break;
            case "hydra":
                newEntity = new Hydra(id, position, config.getInt("hydra_health"), config.getInt("hydra_attack"), 
                    config.getDouble("hydra_health_increase_rate"), config.getDouble("hydra_health_increase_amount")
                );
                getDmc().getPlayer().subscribe((PlayerListener) newEntity);
                break;
            case "treasure":
                newEntity = new CollectibleEntity(id, position, new Treasure(id));
                break;
            case "key":
                newEntity = new CollectibleEntity(id, position, new Key(id, extraInfo.getInt("key")));
                break;
            case "invincibility_potion":
                newEntity = new CollectibleEntity(id, position, new InvincibilityPotion(id, config.getInt("invincibility_potion_duration")));
                break;
            case "invisibility_potion":
                newEntity = new CollectibleEntity(id, position, new InvisibilityPotion(id, config.getInt("invisibility_potion_duration")));
                break;
            case "wood":
                newEntity = new CollectibleEntity(id, position, new Wood(id));
                break;
            case "arrow":
                newEntity = new CollectibleEntity(id, position, new Arrow(id));
                break;
            case "bomb":
                newEntity = new CollectibleEntity(id, position, new Bomb(id, config.getInt("bomb_radius")));
                break;
            case "sword":
                newEntity = new CollectibleEntity(id, position, new Sword(id, config.getInt("sword_attack"), config.getInt("sword_durability")));
                break;
            case "sun_stone":
                newEntity = new CollectibleEntity(id, position, new SunStone(id));
                break;
            case "light_bulb_off":
                newEntity = new LightBulb(id, position, extraInfo.getString("logic"));
                break;
            case "wire":
                newEntity = new Wire(id, position, extraInfo.getString("logic"));
                break;
            case "active_bomb":
                newEntity = new ActiveBomb(id, position, false);
                break;
            case "assassin":
                newEntity = new Assassin(id, position, true, config.getInt("assassin_health"), config.getInt("assassin_attack"), new FollowMovement());
                getDmc().getPlayer().subscribe((PlayerListener) newEntity);
                break;
        }
        if (newEntity != null) {
            getDmc().getAllEntities().add(newEntity);
        } else {
            System.err.println("error: unable to create new entity of type: "+type);
        }
        return newEntity;
    }

    /**
     * Creates the entity from the given JSONObject jsonEntity
     * @param jsonEntity
     */
    public static void createEntity(JSONObject jsonEntity) {
        if (jsonEntity.has("id")) {
            createEntity(jsonEntity.getString("id"), UtilityFunctions.camelToSnake(jsonEntity.getString("type")), getPositionOfEntity(jsonEntity), jsonEntity);
        } else {
            createEntity(UtilityFunctions.camelToSnake(jsonEntity.getString("type")), getPositionOfEntity(jsonEntity), jsonEntity);
        }
    }

    private static Position getPositionOfEntity(JSONObject entity) {
        return new Position(entity.getInt("x"), entity.getInt("y"));
    }
}
